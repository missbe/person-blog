/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50527
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50527
File Encoding         : 65001

Date: 2018-01-04 13:18:09
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `access_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `access_mgt`;
CREATE TABLE `access_mgt` (
  `id` bigint(20) NOT NULL,
  `ip` varchar(255) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of access_mgt
-- ----------------------------
INSERT INTO `access_mgt` VALUES ('1', '127.0.0.1', '2017-06-30 16:51:35');
INSERT INTO `access_mgt` VALUES ('2', '127.0.0.1', '2017-06-30 16:51:36');
INSERT INTO `access_mgt` VALUES ('3', '127.0.0.1', '2017-06-30 16:51:38');
INSERT INTO `access_mgt` VALUES ('4', '127.0.0.1', '2017-06-30 16:55:04');
INSERT INTO `access_mgt` VALUES ('5', '127.0.0.1', '2017-06-30 16:55:05');
INSERT INTO `access_mgt` VALUES ('6', '127.0.0.1', '2017-06-30 16:55:05');
INSERT INTO `access_mgt` VALUES ('7', '127.0.0.1', '2017-06-30 17:04:24');
INSERT INTO `access_mgt` VALUES ('8', '127.0.0.1', '2017-06-30 17:04:25');
INSERT INTO `access_mgt` VALUES ('9', '127.0.0.1', '2017-06-30 17:04:26');
INSERT INTO `access_mgt` VALUES ('10', '127.0.0.1', '2017-06-30 17:16:54');
INSERT INTO `access_mgt` VALUES ('11', '127.0.0.1', '2017-06-30 17:16:55');
INSERT INTO `access_mgt` VALUES ('12', '127.0.0.1', '2017-06-30 17:16:56');
INSERT INTO `access_mgt` VALUES ('13', '127.0.0.1', '2017-06-30 17:21:10');
INSERT INTO `access_mgt` VALUES ('14', '127.0.0.1', '2017-06-30 17:21:11');
INSERT INTO `access_mgt` VALUES ('15', '127.0.0.1', '2017-06-30 17:21:12');
INSERT INTO `access_mgt` VALUES ('16', '127.0.0.1', '2017-06-30 17:23:54');
INSERT INTO `access_mgt` VALUES ('17', '127.0.0.1', '2017-06-30 17:23:55');
INSERT INTO `access_mgt` VALUES ('18', '127.0.0.1', '2017-06-30 17:23:56');
INSERT INTO `access_mgt` VALUES ('30', '127.0.0.1', '2017-06-30 17:34:22');
INSERT INTO `access_mgt` VALUES ('31', '127.0.0.1', '2017-06-30 17:46:14');
INSERT INTO `access_mgt` VALUES ('32', '127.0.0.1', '2017-06-30 17:46:15');
INSERT INTO `access_mgt` VALUES ('33', '127.0.0.1', '2017-06-30 17:46:17');
INSERT INTO `access_mgt` VALUES ('34', '127.0.0.1', '2017-06-30 18:55:51');
INSERT INTO `access_mgt` VALUES ('35', '127.0.0.1', '2017-06-30 18:55:52');
INSERT INTO `access_mgt` VALUES ('36', '127.0.0.1', '2017-06-30 18:55:56');
INSERT INTO `access_mgt` VALUES ('37', '127.0.0.1', '2017-06-30 19:50:03');
INSERT INTO `access_mgt` VALUES ('38', '127.0.0.1', '2017-06-30 19:50:04');
INSERT INTO `access_mgt` VALUES ('39', '127.0.0.1', '2017-06-30 19:50:05');
INSERT INTO `access_mgt` VALUES ('40', '127.0.0.1', '2017-06-30 19:50:19');
INSERT INTO `access_mgt` VALUES ('41', '127.0.0.1', '2017-06-30 20:10:12');

-- ----------------------------
-- Table structure for `blog_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `blog_mgt`;
CREATE TABLE `blog_mgt` (
  `id` bigint(20) NOT NULL,
  `author` varchar(255) DEFAULT NULL,
  `authorAccount` varchar(255) DEFAULT NULL,
  `click` bigint(20) NOT NULL,
  `content` text NOT NULL,
  `date` varchar(255) DEFAULT NULL,
  `image` varchar(255) NOT NULL,
  `menu` varchar(255) NOT NULL,
  `menuName` varchar(255) DEFAULT NULL,
  `recommend` bit(1) NOT NULL,
  `section` varchar(255) NOT NULL,
  `sectionName` varchar(255) DEFAULT NULL,
  `title` varchar(40) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_mgt
-- ----------------------------
INSERT INTO `blog_mgt` VALUES ('29', '不吃猫的鱼', 'admin', '11', '<ul class=\"infos list-paddingleft-2\" style=\"list-style-type: none;\"><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><a href=\"http://ehcache.org/\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">Ehcache</a>&nbsp;是现在最流行的纯Java开源缓存框架，配置简单、结构清晰、功能强大，最初知道它，是从Hibernate的缓存开始的。网上中文的EhCache材料以简单介绍和配置方法居多，如果你有这方面的问题，请自行google；对于API，官网上介绍已经非常清楚，请参见官网；但是很少见到特性说明和对实现原理的分析，因此在这篇文章里面，我会详细介绍和分析EhCache的特性，加上一些自己的理解和思考，希望对缓存感兴趣的朋友有所收获。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">一、特性一览</strong>，来自官网，简单翻译一下：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、快速轻量<br/>过去几年，诸多测试表明Ehcache是最快的Java缓存之一。<br/>Ehcache的线程机制是为大型高并发系统设计的。<br/>大量性能测试用例保证Ehcache在不同版本间性能表现得一致性。<br/>很多用户都不知道他们正在用Ehcache，因为不需要什么特别的配置。<br/>API易于使用，这就很容易部署上线和运行。<br/>很小的jar包，Ehcache 2.2.3才668kb。<br/>最小的依赖：唯一的依赖就是SLF4J了。<br/><br/>2、伸缩性<br/>缓存在内存和磁盘存储可以伸缩到数G，Ehcache为大数据存储做过优化。<br/>大内存的情况下，所有进程可以支持数百G的吞吐。<br/>为高并发和大型多CPU服务器做优化。<br/>线程安全和性能总是一对矛盾，Ehcache的线程机制设计采用了Doug Lea的想法来获得较高的性能。<br/>单台虚拟机上支持多缓存管理器。<br/>通过Terracotta服务器矩阵，可以伸缩到数百个节点。<br/><br/>3、灵活性<br/>Ehcache 1.2具备对象API接口和可序列化API接口。<br/>不能序列化的对象可以使用除磁盘存储外Ehcache的所有功能。<br/>除了元素的返回方法以外，API都是统一的。只有这两个方法不一致：getObjectValue和getKeyValue。这就使得缓存对象、序列化对象来获取新的特性这个过程很简单。<br/>支持基于Cache和基于Element的过期策略，每个Cache的存活时间都是可以设置和控制的。<br/>提供了LRU、LFU和FIFO缓存淘汰算法，Ehcache 1.2引入了最少使用和先进先出缓存淘汰算法，构成了完整的缓存淘汰算法。<br/>提供内存和磁<br/>Ehcache和大多数缓存解决方案一样，提供高性能的内存和磁盘存储。<br/>动态、运行时缓<br/><br/>存活时间、空闲时间、内存和磁盘存放缓存的最大数目都是可以在运行时修改的。<br/><br/>4、标准支持<br/>Ehcache提供了对JSR107 JCACHE API最完整的实现。因为JCACHE在发布以前，Ehcache的实现（如net.sf.jsr107cache）已经发布了。<br/>实现JCACHE API有利于到未来其他缓存解决方案的可移植性。<br/>Ehcache的维护者Greg Luck，正是JSR107的专家委员会委员。<br/><br/>5、可扩展性<br/>监听器可以插件化。Ehcache 1.2提供了CacheManagerEventListener和CacheEventListener接口，实现可以插件化，并且可以在ehcache.xml里配置。<br/>节点发现，冗余器和监听器都可以插件化。<br/>分布式缓存，从Ehcache 1.2开始引入，包含了一些权衡的选项。Ehcache的团队相信没有什么是万能的配置。<br/>实现者可以使用内建的机制或者完全自己实现，因为有完整的插件开发指南。<br/>缓存的可扩展性可以插件化。创建你自己的缓存扩展，它可以持有一个缓存的引用，并且绑定在缓存的生命周期内。<br/>缓存加载器可以插件化。创建你自己的缓存加载器，可以使用一些异步方法来加载数据到缓存里面。<br/>缓存异常处理器可以插件化。创建一个异常处理器，在异常发生的时候，可以执行某些特定操作。<br/><br/>6、应用持久化<br/>在VM重启后，持久化到磁盘的存储可以复原数据。<br/>Ehcache是第一个引入缓存数据持久化存储的开源Java缓存框架。缓存的数据可以在机器重启后从磁盘上重新获得。<br/>根据需要将缓存刷到磁盘。将缓存条目刷到磁盘的操作可以通过cache.flush()方法来执行，这大大方便了Ehcache的使用。<br/><br/>7、监听器<br/>缓存管理器监听器。允许注册实现了CacheManagerEventListener接口的监听器：<br/>notifyCacheAdded()<br/>notifyCacheRemoved()<br/>缓存事件监听器。允许注册实现了CacheEventListener接口的监听器，它提供了许多对缓存事件发生后的处理机制：<br/>notifyElementRemoved/Put/Updated/Expired&nbsp;<br/><br/>8、开启JMX<br/>Ehcache的JMX功能是默认开启的，你可以监控和管理如下的MBean：<br/>CacheManager、Cache、CacheConfiguration、CacheStatistics&nbsp;<br/><br/>9、分布式缓存<br/>从Ehcache 1.2开始，支持高性能的分布式缓存，兼具灵活性和扩展性。<br/>分布式缓存的选项包括：<br/>通过Terracotta的缓存集群：设定和使用Terracotta模式的Ehcache缓存。缓存发现是自动完成的，并且有很多选项可以用来调试缓存行为和性能。<br/>使用RMI、JGroups或者JMS来冗余缓存数据：节点可以通过多播或发现者手动配置。状态更新可以通过RMI连接来异步或者同步完成。<br/>Custom：一个综合的插件机制，支持发现和复制的能力。<br/>可用的缓存复制选项。支持的通过RMI、JGroups或JMS进行的异步或同步的缓存复制。<br/>可靠的分发：使用TCP的内建分发机制。<br/>节点发现：节点可以手动配置或者使用多播自动发现，并且可以自动添加和移除节点。对于多播阻塞的情况下，手动配置可以很好地控制。<br/>分布式缓存可以任意时间加入或者离开集群。缓存可以配置在初始化的时候执行引导程序员。<br/>BootstrapCacheLoaderFactory抽象工厂，实现了BootstrapCacheLoader接口（RMI实现）。<br/>缓存服务端。Ehcache提供了一个Cache Server，一个war包，为绝大多数web容器或者是独立的服务器提供支持。<br/>缓存服务端有两组API：面向资源的RESTful，还有就是SOAP。客户端没有实现语言的限制。<br/>RESTful缓存服务器：Ehcached的实现严格遵循RESTful面向资源的架构风格。<br/>SOAP缓存服务端：Ehcache RESTFul Web Services API暴露了单例的CacheManager，他能在ehcache.xml或者IoC容器里面配置。<br/>标准服务端包含了内嵌的Glassfish web容器。它被打成了war包，可以任意部署到支持Servlet 2.5的web容器内。Glassfish V2/3、Tomcat 6和Jetty 6都已经经过了测试。<br/><br/>10、搜索<br/>标准分布式搜索使用了流式查询接口的方式，请参阅文档。<br/><br/>11、Java EE和应用缓存<br/>为普通缓存场景和模式提供高质量的实现。<br/>阻塞缓存：它的机制避免了复制进程并发操作的问题。<br/>SelfPopulatingCache在缓存一些开销昂贵操作时显得特别有用，它是一种针对读优化的缓存。它不需要调用者知道缓存元素怎样被返回，也支持在不阻塞读的情况下刷新缓存条目。<br/>CachingFilter：一个抽象、可扩展的cache filter。<br/>SimplePageCachingFilter：用于缓存基于request URI和Query String的页面。它可以根据HTTP request header的值来选择采用或者不采用gzip压缩方式将页面发到浏览器端。你可以用它来缓存整个Servlet页面，无论你采用的是JSP、velocity，或者其他的页面渲染技术。<br/>SimplePageFragmentCachingFilter：缓存页面片段，基于request URI和Query String。在JSP中使用jsp:include标签包含。<br/>已经使用Orion和Tomcat测试过，兼容Servlet 2.3、Servlet 2.4规范。<br/>Cacheable命令：这是一种老的命令行模式，支持异步行为、容错。<br/>兼容Hibernate，兼容Google App Engine。<br/>基于JTA的事务支持，支持事务资源管理，二阶段提交和回滚，以及本地事务。<br/><br/>12、开源协议<br/>Apache 2.0 license</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">二、Ehcache的加载模块列表</strong>，他们都是独立的库，每个都为Ehcache添加新的功能，可以<a href=\"http://ehcache.org/downloads/catalog\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">在此下载</a>&nbsp;：</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p>ehcache-core：API，标准缓存引擎，RMI复制和Hibernate支持</p></li><li><p>ehcache：分布式Ehcache，包括Ehcache的核心和Terracotta的库</p></li><li><p>ehcache-monitor：企业级监控和管理</p></li><li><p>ehcache-web：为Java Servlet Container提供缓存、gzip压缩支持的filters</p></li><li><p>ehcache-jcache：JSR107 JCACHE的实现</p></li><li><p>ehcache-jgroupsreplication：使用JGroup的复制</p></li><li><p>ehcache-jmsreplication：使用JMS的复制</p></li><li><p>ehcache-openjpa：OpenJPA插件</p></li><li><p>ehcache-server：war内部署或者单独部署的RESTful cache server</p></li><li><p>ehcache-unlockedreadsview：允许Terracotta cache的无锁读</p></li><li><p>ehcache-debugger：记录RMI分布式调用事件</p></li><li><p>Ehcache for Ruby：Jruby and Rails支持</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Ehcache的结构设计概览：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9564/7c190eee-cddf-3ab5-9a9d-fc9c94c1e7e8.jpg\" title=\"点击查看原始大小图片\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">三、核心定义</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">cache manager：缓存管理器，以前是只允许单例的，不过现在也可以多实例了</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">cache：缓存管理器内可以放置若干cache，存放数据的实质，所有cache都实现了Ehcache接口</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">element：单条缓存数据的组成单位</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">system of record（SOR）：可以取到真实数据的组件，可以是真正的业务逻辑、外部接口调用、存放真实数据的数据库等等，缓存就是从SOR中读取或者写入到SOR中去的。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">代码示例：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Java代码&nbsp;</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">CacheManager&nbsp;manager&nbsp;=&nbsp;CacheManager.newInstance(&quot;src/config/ehcache.xml&quot;);&nbsp;&nbsp;\nmanager.addCache(&quot;testCache&quot;);&nbsp;&nbsp;\nCache&nbsp;test&nbsp;=&nbsp;singletonManager.getCache(&quot;testCache&quot;);&nbsp;&nbsp;\ntest.put(new&nbsp;Element(&quot;key1&quot;,&nbsp;&quot;value1&quot;));&nbsp;&nbsp;\nmanager.shutdown();</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">当然，也支持这种类似DSL的配置方式，配置都是可以在运行时动态修改的：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Java代码&nbsp;</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">Cache&nbsp;testCache&nbsp;=&nbsp;new&nbsp;Cache(&nbsp;&nbsp;\n&nbsp;&nbsp;new&nbsp;CacheConfiguration(&quot;testCache&quot;,&nbsp;maxElements)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.overflowToDisk(true)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.eternal(false)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.timeToLiveSeconds(60)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.timeToIdleSeconds(30)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.diskPersistent(false)&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;.diskExpiryThreadIntervalSeconds(0));</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">事务的例子：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Java代码</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">Ehcache&nbsp;cache&nbsp;=&nbsp;cacheManager.getEhcache(&quot;xaCache&quot;);&nbsp;&nbsp;\ntransactionManager.begin();&nbsp;&nbsp;\ntry&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;Element&nbsp;e&nbsp;=&nbsp;cache.get(key);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;result&nbsp;=&nbsp;complexService.doStuff(element.getValue());&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;cache.put(new&nbsp;Element(key,&nbsp;result));&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;complexService.doMoreStuff(result);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;transactionManager.commit();&nbsp;&nbsp;\n}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;transactionManager.rollback();&nbsp;&nbsp;\n}</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">四、一致性模型</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">说到一致性，数据库的一致性是怎样的？不妨先来回顾一下数据库的几个隔离级别：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">未提交读（Read Uncommitted）：在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据。会出现脏读、不可重复读、幻象读。<br/>已提交读（Read Committed）：只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是数据库的默认隔离级别。会出现不可重复读、幻象读。<br/>可重复读（Repeatable Read）：像已提交读级别那样读数据，但会保持共享锁直到事务结束。会出现幻象读。<br/>可序列化（Serializable）：工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围，这就阻止了新数据插入查询所涉及的范围。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">基于以上，再来对比思考下面的一致性模型：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、强一致性模型：系统中的某个数据被成功更新(事务成功返回)后，后续任何对该数据的读取操作都得到更新后的值。这是传统关系数据库提供的一致性模型，也是关系数据库深受人们喜爱的原因之一。强一致性模型下的性能消耗通常是最大的。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、弱一致性模型：系统中的某个数据被更新后，后续对该数据的读取操作得到的不一定是更新后的值，这种情况下通常有个“不一致性时间窗口”存在：即数据更新完成后在经过这个时间窗口，后续读取操作就能够得到更新后的值。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、最终一致性模型：属于弱一致性的一种，即某个数据被更新后，如果该数据后续没有被再次更新，那么最终所有的读取操作都会返回更新后的值。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">最终一致性模型包含如下几个必要属性，都比较好理解：</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p>读写一致：某线程A，更新某条数据以后，后续的访问全部都能取得更新后的数据。</p></li><li><p>会话内一致：它本质上和上面那一条是一致的，某用户更改了数据，只要会话还存在，后续他取得的所有数据都必须是更改后的数据。</p></li><li><p>单调读一致：如果一个进程可以看到当前的值，那么后续的访问不能返回之前的值。</p></li><li><p>单调写一致：对同一进程内的写行为必须是保序的，否则，写完毕的结果就是不可预期的了。</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">4、Bulk Load：这种模型是基于批量加载数据到缓存里面的场景而优化的，没有引入锁和常规的淘汰算法这些降低性能的东西，它和最终一致性模型很像，但是有批量、高速写和弱一致性保证的机制。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">这样几个API也会影响到一致性的结果：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、显式锁（<a href=\"http://terracotta.org/documentation/enterprise-ehcache/api-guide#31478\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">Explicit Locking</a>&nbsp;）：如果我们本身就配置为强一致性，那么自然所有的缓存操作都具备事务性质。而如果我们配置成最终一致性时，再在外部使用显式锁API，也可以达到事务的效果。当然这样的锁可以控制得更细粒度，但是依然可能存在竞争和线程阻塞。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、无锁可读取视图（UnlockedReadsView）：一个允许脏读的decorator，它只能用在强一致性的配置下，它通过申请一个特殊的写锁来比完全的强一致性配置提升性能。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">举例如下，xml配置为强一致性模型：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Xml代码</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">&lt;cache&nbsp;name=&quot;myCache&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxElementsInMemory=&quot;500&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eternal=&quot;false&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overflowToDisk=&quot;false&quot;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&lt;terracotta&nbsp;clustered=&quot;true&quot;&nbsp;consistency=&quot;strong&quot;&nbsp;/&gt;&nbsp;&nbsp;&lt;/cache&gt;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">但是使用UnlockedReadsView：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Java代码</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">Cache&nbsp;cache&nbsp;=&nbsp;cacheManager.getEhcache(&quot;myCache&quot;);&nbsp;&nbsp;\nUnlockedReadsView&nbsp;unlockedReadsView&nbsp;=&nbsp;new&nbsp;UnlockedReadsView(cache,&nbsp;&quot;myUnlockedCache&quot;);</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、原子方法（Atomic methods）：方法执行是原子化的，即CAS操作（Compare and Swap）。CAS最终也实现了强一致性的效果，但不同的是，它是采用乐观锁而不是悲观锁来实现的。在乐观锁机制下，更新的操作可能不成功，因为在这过程中可能会有其他线程对同一条数据进行变更，那么在失败后需要重新执行更新操作。现代的CPU都支持CAS原语了。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Java代码</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">cache.putIfAbsent(Element&nbsp;element);&nbsp;&nbsp;\ncache.replace(Element&nbsp;oldOne,&nbsp;Element&nbsp;newOne);&nbsp;&nbsp;\ncache.remove(Element);</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">五、缓存拓扑类型</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、独立缓存（Standalone Ehcache）：这样的缓存应用节点都是独立的，互相不通信。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、分布式缓存（Distributed Ehcache）：数据存储在Terracotta的服务器阵列（Terracotta Server Array，TSA）中，但是最近使用的数据，可以存储在各个应用节点中。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">逻辑视角：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9262/87a2e6c1-d9ee-3ae8-aa37-5857ad1b0cc9.png\"/><br/>L1缓存就在各个应用节点上，而L2缓存则放在Cache Server阵列中。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">组网视角：<br/><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9271/27135d72-600a-34c8-a067-d3c48dff43a9.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">模型存储视角：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9275/a1471f73-1bfb-387a-a9e8-501b3dfbd0b4.png\"/><br/>L1级缓存是没有持久化存储的。另外，从缓存数据量上看，server端远大于应用节点。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、复制式缓存（Replicated Ehcache）：缓存数据时同时存放在多个应用节点的，数据复制和失效的事件以同步或者异步的形式在各个集群节点间传播。上述事件到来时，会阻塞写线程的操作。在这种模式下，只有弱一致性模型。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">它有如下几种事件传播机制：RMI、JGroups、JMS和Cache Server。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">RMI模式下，所有节点全部对等：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9566/a60e3ce7-5121-310b-8989-c25a8c1bfc30.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">JGroup模式：可以配置单播或者多播，协议栈和配置都非常灵活。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Xml代码&nbsp;</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">&lt;cacheManagerPeerProviderFactory&nbsp;&nbsp;class=&quot;net.sf.ehcache.distribution.jgroups.JGroupsCacheManagerPeerProviderFactory&quot;&nbsp;&nbsp;properties=&quot;connect=UDP(mcast_addr=231.12.21.132;mcast_port=45566;):PING:&nbsp;&nbsp;\nMERGE2:FD_SOCK:VERIFY_SUSPECT:pbcast.NAKACK:UNICAST:pbcast.STABLE:FRAG:pbcast.GMS&quot;&nbsp;&nbsp;propertySeparator=&quot;::&quot;&nbsp;&nbsp;/&gt;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">JMS模式：这种模式的核心就是一个消息队列，每个应用节点都订阅预先定义好的主题，同时，节点有元素更新时，也会发布更新元素到主题中去。JMS规范实现者上，Open MQ和Active MQ这两个，Ehcache的兼容性都已经测试过。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9572/5d07bfbe-656f-3e0d-9e6b-ff0e251c63e8.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Cache Server模式：这种模式下存在主从节点，通信可以通过RESTful的API或者SOAP。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9570/b4776499-b37c-32e7-8dd6-b0285bbe8820.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">无论上面哪个模式，更新事件又可以分为updateViaCopy或updateViaInvalidate，后者只是发送一个过期消息，效率要高得多。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">复制式缓存容易出现数据不一致的问题，如果这成为一个问题，可以考虑使用数据同步分发的机制。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">即便不采用分布式缓存和复制式缓存，依然会出现一些不好的行为，比如：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">缓存漂移（Cache Drift）：每个应用节点只管理自己的缓存，在更新某个节点的时候，不会影响到其他的节点，这样数据之间可能就不同步了。这在web会话数据缓存中情况尤甚。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">数据库瓶颈（Database Bottlenecks ）：对于单实例的应用来说，缓存可以保护数据库的读风暴；但是，在集群的环境下，每一个应用节点都要定期保持数据最新，节点越多，要维持这样的情况对数据库的开销也越大。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">六、存储方式</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、堆内存储：速度快，但是容量有限。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、堆外（OffHeapStore）存储：被称为BigMemory，只在企业版本的Ehcache中提供，原理是利用nio的DirectByteBuffers实现，比存储到磁盘上快，而且完全不受GC的影响，可以保证响应时间的稳定性；但是direct buffer的在分配上的开销要比heap buffer大，而且要求必须以字节数组方式存储，因此对象必须在存储过程中进行序列化，读取则进行反序列化操作，它的速度大约比堆内存储慢一个数量级。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">（注：direct buffer不受GC影响，但是direct buffer归属的的JAVA对象是在堆上且能够被GC回收的，一旦它被回收，JVM将释放direct buffer的堆外空间。）</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、磁盘存储。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">七、缓存使用模式</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">cache-aside：直接操作。先询问cache某条缓存数据是否存在，存在的话直接从cache中返回数据，绕过SOR；如果不存在，从SOR中取得数据，然后再放入cache中。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Java代码</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">public&nbsp;V&nbsp;readSomeData(K&nbsp;key)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;Element&nbsp;element;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;if&nbsp;((element&nbsp;=&nbsp;cache.get(key))&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;element.getValue();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;if&nbsp;(value&nbsp;=&nbsp;readDataFromDataStore(key))&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.put(new&nbsp;Element(key,&nbsp;value));&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;return&nbsp;value;&nbsp;&nbsp;\n}</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">cache-as-sor：结合了read-through、write-through或write-behind操作，通过给SOR增加了一层代理，对外部应用访问来说，它不用区别数据是从缓存中还是从SOR中取得的。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">read-through。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">write-through。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">write-behind（write-back）：既将写的过程变为异步的，又进一步延迟写入数据的过程。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Copy Cache的两个模式：CopyOnRead和CopyOnWrite。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">CopyOnRead指的是在读缓存数据的请求到达时，如果发现数据已经过期，需要重新从源处获取，发起的copy element的操作（pull）；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">CopyOnWrite则是发生在真实数据写入缓存时，发起的更新其他节点的copy element的操作（push）。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">前者适合在不允许多个线程访问同一个element的时候使用，后者则允许你自由控制缓存更新通知的时机。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">更多push和pull的变化和不同，也可<a href=\"http://raychase.iteye.com/blog/1337015\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">参见这里</a>。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">八、多种配置方式</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">包括配置文件、声明式配置、编程式配置，甚至通过指定构造器的参数来完成配置，配置设计的原则包括：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">所有配置要放到一起</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">缓存的配置可以很容易在开发阶段、运行时修改</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">错误的配置能够在程序启动时发现，在运行时修改出错则需要抛出运行时异常</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">提供默认配置，几乎所有的配置都是可选的，都有默认值</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">九、自动资源控制</strong>（Automatic Resource Control，ARC）：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">它是提供了一种智能途径来控制缓存，调优性能。特性包括：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">内存内缓存对象大小的控制，避免OOM出现</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">池化（cache manager级别）的缓存大小获取，避免单独计算缓存大小的消耗</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">灵活的独立基于层的大小计算能力，下图中可以看到，不同层的大小都是可以单独控制的</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">可以统计字节大小、缓存条目数和百分比</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">优化高命中数据的获取，以提升性能，参见下面对缓存数据在不同层之间的流转的介绍</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9538/63c24f8c-b843-3bc3-b6b2-782bf0c32a94.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">缓存数据的流转包括了这样几种行为：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Flush：缓存条目向低层次移动。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Fault：从低层拷贝一个对象到高层。在获取缓存的过程中，某一层发现自己的该缓存条目已经失效，就触发了Fault行为。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Eviction：把缓存条目除去。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Expiration：失效状态。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Pinning：强制缓存条目保持在某一层。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">下面的图反映了数据在各个层之间的流转，也反映了数据的生命周期：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9558/32a34da8-4048-32c9-b7fb-99f1c6e536dc.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">十、监控功能</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">监控的拓扑：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9560/c05ffb58-9d78-3483-af25-f14b02cf01aa.png\"/><br/>每个应用节点部署一个监控探针，通过TCP协议与监控服务器联系，最终将数据提供给富文本客户端或者监控操作服务器。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">十一、广域网复制</strong>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">缓存数据复制方面，Ehcache允许两个地理位置各异的节点在广域网下维持数据一致性，同时它提供了这样几种方案（注：下面的示例都只绘制了两个节点的情形，实际可以推广到N个节点）：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">第一种方案：Terracotta Active/Mirror Replication。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9577/5252c7db-281c-3c10-ac55-fce593fd65f2.png\"/><br/>这种方案下，服务端包含一个活跃节点，一个备份节点；各个应用节点全部靠该活跃节点提供读写服务。这种方式最简单，管理容易；但是，需要寄希望于理想的网络状况，服务器之间和客户端到服务器之间都存在走WAN的情况，这样的方案其实最不稳定。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">第二种方案：Transactional Cache Manager Replication。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9589/5e44ec5e-335a-3cf2-8291-8e0a232cc00a.png\"/><br/>这种方案下，数据读取不需要经过WAN，写入数据时写入两份，分别由两个cache manager处理，一份在本地Server，一份到其他Server去。这种方案下读的吞吐量较高而且延迟较低；但是需要引入一个XA事务管理器，两个cache manager写两份数据导致写开销较大，而且过WAN的写延迟依然可能导致系统响应的瓶颈。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">第三种方案：Messaging based (AMQ) replication。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9596/976fff5d-f568-3a83-8077-d44c95cae5d1.png\" title=\"点击查看原始大小图片\"/><br/>这种方案下，引入了批量处理和队列，用以减缓WAN的瓶颈出现，同时，把处理读请求和复制逻辑从Server Array物理上就剥离开，避免了WAN情况恶化对节点读取业务的影响。这种方案要较高的吞吐量和较低的延迟，读/复制的分离保证了可以提供完备的消息分发保证、冲突处理等特性；但是它较为复杂，而且还需要一个消息总线。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">有一些Ehcache特性应用较少或者比较边缘化，没有提到，例如对于JMX的支持；还有一些则是有类似的特性和介绍了，例如对于WEB的支持，请参见我<a href=\"http://raychase.iteye.com/blog/1533153\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">这篇关于OSCache的解读</a>，其中的“web支持”一节有详细的原理分析。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">最后，关于Ehcache的性能比对，下面这张图来自Ehcache的创始人<a href=\"http://gregluck.com/blog/archives/2007/05/comparing-memcached-and-ehcache-performance/\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">Greg Luck的blog</a>：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://dl.iteye.com/upload/attachment/0068/9600/67ba18b1-6772-3e02-95a1-599ac9d59360.gif\"/>&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">put/get上Ehcache要500-1000倍快过Memcached。原因何在？他自己分析道：“In-process caching and asynchronous replication are a clear performance winner”。有关它详细的内容还是请参阅他的blog吧。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">原文地址：<a href=\"http://raychase.iteye.com/blog/1545906\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">http://raychase.iteye.com/blog/1545906</a></p></ul><p><br/></p>', '2017-06-30 17:33:35', 'http://dl.iteye.com/upload/attachment/0068/9564/7c190eee-cddf-3ab5-9a9d-fc9c94c1e7e8.jpg', '20', '好文推荐', '', '25', '技术博客', 'Ehcache详细解读');
INSERT INTO `blog_mgt` VALUES ('42', '不吃猫的鱼', 'admin', '3', '<h2 style=\"margin: 0px 0px 20px; padding: 0px; font-weight: normal; font-family: &#39;Architects Daughter&#39;, cursive; color: rgb(100, 149, 237);\">Just about me</h2><ul style=\"list-style-type: none;\" class=\" list-paddingleft-2\"><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">简介:</strong>&nbsp;依然慢节奏，男，现四川理工学院计算机学院一名在校大学生！热爱IT技术,喜欢钻研新技术。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img src=\"/upload/image/20170705/1499184296853095427.jpg\" title=\"1499184296853095427.jpg\" alt=\"1499184296853095427.jpg\" width=\"300\" height=\"500\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">技术相关:</strong>&nbsp;主要从事Java web开发，熟悉web前后端的开发。具有独立开发项目的能力。熟练使用各种前端框架（jQuery，bootstrap，easyUI等），了解h5+，熟练使用JSP、freemarker等Java前端数据渲染模板，熟练使用多种Java web后台开发框架 （JFinal、SpringMVC、Spring、Mybaits、Struts2、hibernate、shiro等），熟练使用ajax、json、Jsoup进行前后端数据交互。喜欢Java语言，Java基础扎实，喜欢研究框架的设计模式及底层原理。除了Java之外最熟悉C#语言（两门语言本来就很像），能开发基于asp.net webform的web应用。除了web应用之外还能使用Java Swing、 C# winform开发PC桌面应用。熟悉网络爬虫。能开发简单的爬虫程序。具有良好的数据库设计能力，熟悉主流关系型数据库（MySQL、sqlserver等），能熟练编写SQL语句以及储存过程。熟悉IIS下基于asp.net的web项目部署、Tomcat下Java web项目的部署。了解jetty、Jboss、weblogic等Java web服务器&nbsp;</p></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">服务器：</strong>腾讯云服务器</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">备案号：</strong>蜀ICP备16036750号</p><p><br/></p>', '2017-06-30 22:13:21', '/upload/image/20170705/1499184296853095427.jpg', '21', '生活札记', '', '23', '纪念', '关于我');
INSERT INTO `blog_mgt` VALUES ('43', '不吃猫的鱼', 'admin', '1', '<ul class=\"infos list-paddingleft-2\" style=\"list-style-type: none;\"><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">前言</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">由于Sencha Touch 2这种开发模式的特性，基本决定了它原生的数据交互行为几乎只能通过AJAX来实现。<img src=\"/upload/image/20170914/1505395968684015072.jpg\" title=\"1505395968684015072.jpg\" alt=\"1505395968684015072.jpg\" width=\"360\" height=\"250\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">当然了，通过调用强大的PhoneGap插件然后打包，你可以实现100%的Socket通讯和本地数据库功能，又或者通过HTML5的WebSocket也可以实现与服务器的通讯和服务端推功能，但这两种方式都有其局限性，前者需要PhoneGap支持，后者要求用户设备必须支持WebSocket，因此都不能算是ST2的原生解决方案，原生的只有AJAX。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">JSON(JavaScript Object Notation)和JSONP(JSON with Padding)虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">什么是JSON</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">JSON的优点：</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、基于纯文本，跨平台传递极其简单；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、Javascript原生支持，后台语言几乎全部支持；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、轻量级数据格式，占用字符数量极少，特别适合互联网传递；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">4、可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">5、容易编写和解析，当然前提是你要知道数据结构；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。<img src=\"/upload/image/20170914/1505396031024071987.jpg\" title=\"1505396031024071987.jpg\" alt=\"1505396031024071987.jpg\" width=\"400\" height=\"330\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">JSON的格式或者叫规则：</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号&quot;&quot;是定义符。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”&quot;，以便于不同语言的解析。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">JSON实例： &nbsp;</strong></p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">//&nbsp;描述一个人&nbsp;\nvar&nbsp;person&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;Bob&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;32,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;IBM&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;true\n}\n&nbsp;\n//&nbsp;获取这个人的信息&nbsp;\nvar&nbsp;personAge&nbsp;=&nbsp;person.Age;\n&nbsp;\n//&nbsp;描述几个人&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;members&nbsp;=&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;Bob&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;32,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;IBM&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;true\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;John&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;20,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;Oracle&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;false\n&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;Henry&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;45,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;Microsoft&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;false\n&nbsp;&nbsp;&nbsp;&nbsp;}\n]\n&nbsp;\n//&nbsp;读取其中John的公司名称&nbsp;\nvar&nbsp;johnsCompany&nbsp;=&nbsp;members[1].Company;\n&nbsp;\n//&nbsp;描述一次会议&nbsp;\nvar&nbsp;conference&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Conference&quot;:&nbsp;&quot;Future&nbsp;Marketing&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Date&quot;:&nbsp;&quot;2012-6-1&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Address&quot;:&nbsp;&quot;Beijing&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Members&quot;:\n&nbsp;&nbsp;&nbsp;&nbsp;[\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;Bob&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;32,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;IBM&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;true\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;John&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;20,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;Oracle&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Name&quot;:&nbsp;&quot;Henry&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Age&quot;:&nbsp;45,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Company&quot;:&nbsp;&quot;Microsoft&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Engineer&quot;:&nbsp;false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;]\n}\n&nbsp;\n//&nbsp;读取参会者Henry是否工程师&nbsp;\nvar&nbsp;henryIsAnEngineer&nbsp;=&nbsp;conference.Members[2].Engineer;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">什么是JSONP</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">先说说JSONP是怎么产生的：</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">JSONP的客户端具体实现：</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">不管jQuery也好，ExtJs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">远程服务器remoteserver.com根目录下有个remote.js文件代码如下：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">alert(&#39;我是远程文件&#39;);</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">本地服务器localserver.com下有个jsonp.html页面代码如下：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Transitional//EN&quot;&nbsp;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html&nbsp;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&lt;/title&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp;\n&lt;/body&gt;\n&lt;/html&gt;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">jsonp.html页面代码如下：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Transitional//EN&quot;&nbsp;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html&nbsp;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&lt;/title&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;localHandler&nbsp;=&nbsp;function(data){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&#39;&nbsp;+&nbsp;data.result);\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp;\n&lt;/body&gt;\n&lt;/html&gt;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">remote.js文件代码如下：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">看jsonp.html页面的代码：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Transitional//EN&quot;&nbsp;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html&nbsp;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&lt;/title&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;得到航班信息查询结果后的回调函数\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;flightHandler&nbsp;=&nbsp;function(data){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;你查询的航班结果是：票价&nbsp;&#39;&nbsp;+&nbsp;data.price&nbsp;+&nbsp;&#39;&nbsp;元，&#39;&nbsp;+&nbsp;&#39;余票&nbsp;&#39;&nbsp;+&nbsp;data.tickets&nbsp;+&nbsp;&#39;&nbsp;张。&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;url&nbsp;=&nbsp;&quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建script标签，设置其属性\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;script&nbsp;=&nbsp;document.createElement(&#39;script&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;script.setAttribute(&#39;src&#39;,&nbsp;url);\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把script标签加入head，此时调用开始\n&nbsp;&nbsp;&nbsp;&nbsp;document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp;\n&lt;/body&gt;\n&lt;/html&gt;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">flightHandler({\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;code&quot;:&nbsp;&quot;CA1998&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;price&quot;:&nbsp;1780,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;tickets&quot;:&nbsp;5\n});</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">　　我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">　　4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">　　什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Transitional//EN&quot;&nbsp;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&nbsp;&lt;html&nbsp;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&nbsp;&gt;\n&nbsp;&lt;head&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;Untitled&nbsp;Page&lt;/title&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=jquery.min.js&quot;&gt;&lt;/script&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery(document).ready(function(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&quot;get&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async:&nbsp;false,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;&quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataType:&nbsp;&quot;jsonp&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonp:&nbsp;&quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function(json){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;您查询到航班信息：票价：&nbsp;&#39;&nbsp;+&nbsp;json.price&nbsp;+&nbsp;&#39;&nbsp;元，余票：&nbsp;&#39;&nbsp;+&nbsp;json.tickets&nbsp;+&nbsp;&#39;&nbsp;张。&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;function(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;fail&#39;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;\n&nbsp;&nbsp;&lt;body&gt;\n&nbsp;&nbsp;&lt;/body&gt;\n&nbsp;&lt;/html&gt;</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">好啦，写到这里，我已经无力再写下去，又困又累，得赶紧睡觉。朋友们要是看这不错，觉得有启发，给点个“推荐”呗！由于实在比较简单，所以就不再提供demo源码下载了。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">没想到上了博客园的头条推荐。看到大家对这篇文章的认可和评论，还是很开心的，这里针对ajax与jsonp的异同再做一些补充说明：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">4月20日下午补充</strong></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; &nbsp; &nbsp;原文链接:<a href=\"http://kb.cnblogs.com/page/139725/\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">http://kb.cnblogs.com/page/139725/</a></p></ul><p><br/></p>', '2017-06-30 22:14:56', '/upload/image/20170914/1505395968684015072.jpg', '20', '好文推荐', '', '28', '经典文章', '说说JSON和JSONP，也许你会豁然开朗');
INSERT INTO `blog_mgt` VALUES ('44', '不吃猫的鱼', 'admin', '6', '<ul class=\"infos list-paddingleft-2\" style=\"list-style-type: none;\"><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">通过maven构建web项目。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">在pol.xml加入内置jetty插件，通过maven命令 jetty:run即可运行web项目。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img src=\"/upload/image/20170914/1505396300712066033.jpg\" title=\"1505396300712066033.jpg\" alt=\"0d41c81f959163ab.jpg\" width=\"653\" height=\"336\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">内存不够可在上图的runner-》vm options加入：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">-server -Xms256m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=2048m</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">pom.xml:<br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(169, 183, 198); font-family: Menlo; font-size: 10.5pt; background-color: rgb(43, 43, 43);\">&lt;!--&nbsp;jetty运行&nbsp;mvn&nbsp;jetty:run&nbsp;--&gt;\n&lt;plugin&gt;\n&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;\n&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;\n&nbsp;&nbsp;&nbsp;&lt;version&gt;9.2.18.v20160721&lt;/version&gt;\n&lt;/plugin&gt;</pre></ul><p><br/></p>', '2017-06-30 22:15:37', '/upload/image/20170914/1505396300712066033.jpg', '20', '好文推荐', '', '27', '开源技术', 'Intellij社区版java web开发');
INSERT INTO `blog_mgt` VALUES ('45', '不吃猫的鱼', 'admin', '2', '<ul class=\"infos list-paddingleft-2\" style=\"list-style-type: none;\"><h1 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a href=\"http://www.cnblogs.com/wawlian/archive/2012/06/18/2553061.html\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">网络爬虫基本原理(一)</a></h1><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 网络爬虫是捜索引擎抓取系统的重要组成部分。爬虫的主要目的是将互联网上的网页下载到本地形成一个或联网内容的镜像备份。这篇博客主要对爬虫以及抓取系统进行一个简单的概述。<img src=\"/upload/image/20170914/1505396150002008886.jpg\" title=\"1505396150002008886.jpg\" alt=\"1505396150002008886.jpg\" width=\"400\" height=\"300\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">一、网络爬虫的基本结构及工作流程</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 一个通用的网络爬虫的框架如图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061802175319.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 网络爬虫的基本工作流程如下：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 1.首先选取一部分精心挑选的种子URL；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 2.将这些URL放入待抓取URL队列；</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 3.从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 4.分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">二、从爬虫的角度对互联网进行划分</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 对应的，可以将互联网的所有页面分为五个部分：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061802181363.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 1.已下载未过期网页</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 2.已下载已过期网页：抓取到的网页实际上是互联网内容的一个镜像与备份，互联网是动态变化的，一部分互联网上的内容已经发生了变化，这时，这部分抓取到的网页就已经过期了。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 3.待下载网页：也就是待抓取URL队列中的那些页面</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 4.可知网页：还没有抓取下来，也没有在待抓取URL队列中，但是可以通过对已抓取页面或者待抓取URL对应页面进行分析获取到的URL，认为是可知网页。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 5.还有一部分网页，爬虫是无法直接抓取下载的。称为不可知网页。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">三、抓取策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 在爬虫系统中，待抓取URL队列是很重要的一部分。待抓取URL队列中的URL以什么样的顺序排列也是一个很重要的问题，因为这涉及到先抓取那个页面，后抓取哪个页面。而决定这些URL排列顺序的方法，叫做抓取策略。下面重点介绍几种常见的抓取策略：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 1.深度优先遍历策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">深度优先遍历策略是指网络爬虫会从起始页开始，一个链接一个链接跟踪下去，处理完这条线路之后再转入下一个起始页，继续跟踪链接。我们以下面的图为例：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061802182688.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 遍历的路径：A-F-G&nbsp; E-H-I B C D</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 2.宽度优先遍历策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 宽度优先遍历策略的基本思路是，将新下载网页中发现的链接直接插入待抓取URL队列的末尾。也就是指网络爬虫会先抓取起始网页中链接的所有网页，然后再选择其中的一个链接网页，继续抓取在此网页中链接的所有网页。还是以上面的图为例：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 遍历路径：A-B-C-D-E-F G H I</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 3.反向链接数策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 反向链接数是指一个网页被其他网页链接指向的数量。反向链接数表示的是一个网页的内容受到其他人的推荐的程度。因此，很多时候搜索引擎的抓取系统会使用这个指标来评价网页的重要程度，从而决定不同网页的抓取先后顺序。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 在真实的网络环境中，由于广告链接、作弊链接的存在，反向链接数不能完全等他我那个也的重要程度。因此，搜索引擎往往考虑一些可靠的反向链接数。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 4.Partial PageRank策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; Partial PageRank算法借鉴了PageRank算法的思想：对于已经下载的网页，连同待抓取URL队列中的URL，形成网页集合，计算每个页面的PageRank值，计算完之后，将待抓取URL队列中的URL按照PageRank值的大小排列，并按照该顺序抓取页面。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 如果每次抓取一个页面，就重新计算PageRank值，一种折中方案是：每抓取K个页面后，重新计算一次PageRank值。但是这种情况还会有一个问题：对于已经下载下来的页面中分析出的链接，也就是我们之前提到的未知网页那一部分，暂时是没有PageRank值的。为了解决这个问题，会给这些页面一个临时的PageRank值：将这个网页所有入链传递进来的PageRank值进行汇总，这样就形成了该未知页面的PageRank值，从而参与排序。下面举例说明：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 5.OPIC策略策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 该算法实际上也是对页面进行一个重要性打分。在算法开始前，给所有页面一个相同的初始现金（cash）。当下载了某个页面P之后，将P的现金分摊给所有从P中分析出的链接，并且将P的现金清空。对于待抓取URL队列中的所有页面按照现金数进行排序。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 6.大站优先策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp; 对于待抓取URL队列中的所有网页，根据所属的网站进行分类。对于待下载页面数多的网站，优先下载。这个策略也因此叫做大站优先策略。&nbsp;</p><h1 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a href=\"http://www.cnblogs.com/wawlian/archive/2012/06/18/2554072.html\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">网络爬虫基本原理(二)</a></h1><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">四、更新策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 互联网是实时变化的，具有很强的动态性。网页更新策略主要是决定何时更新之前已经下载过的页面。常见的更新策略又以下三种：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 1.历史参考策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 顾名思义，根据页面以往的历史更新数据，预测该页面未来何时会发生变化。一般来说，是通过泊松过程进行建模进行预测。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 2.用户体验策略<br/>&nbsp;&nbsp;&nbsp;&nbsp;尽管搜索引擎针对于某个查询条件能够返回数量巨大的结果，但是用户往往只关注前几页结果。因此，抓取系统可以优先更新那些现实在查询结果前几页中的网页，而后再更新那些后面的网页。这种更新策略也是需要用到历史信息的。用户体验策略保留网页的多个历史版本，并且根据过去每次内容变化对搜索质量的影响，得出一个平均值，用这个值作为决定何时重新抓取的依据。<br/>&nbsp;&nbsp;&nbsp;&nbsp;3.聚类抽样策略</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 前面提到的两种更新策略都有一个前提：需要网页的历史信息。这样就存在两个问题：第一，系统要是为每个系统保存多个版本的历史信息，无疑增加了很多的系统负担；第二，要是新的网页完全没有历史信息，就无法确定更新策略。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 这种策略认为，网页具有很多属性，类似属性的网页，可以认为其更新频率也是类似的。要计算某一个类别网页的更新频率，只需要对这一类网页抽样，以他们的更新周期作为整个类别的更新周期。基本思路如图：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061822045073.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">五、分布式抓取系统结构<br/>&nbsp; &nbsp; 一般来说，抓取系统需要面对的是整个互联网上数以亿计的网页。单个抓取程序不可能完成这样的任务。往往需要多个抓取程序一起来处理。一般来说抓取系统往往是一个分布式的三层结构。如图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061822055037.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 最下一层是分布在不同地理位置的数据中心，在每个数据中心里有若干台抓取服务器，而每台抓取服务器上可能部署了若干套爬虫程序。这就构成了一个基本的分布式抓取系统。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 对于一个数据中心内的不同抓去服务器，协同工作的方式有几种：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 1.主从式（Master-Slave）</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 主从式基本结构如图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061822061880.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 对于主从式而言，有一台专门的Master服务器来维护待抓取URL队列，它负责每次将URL分发到不同的Slave服务器，而Slave服务器则负责实际的网页下载工作。Master服务器除了维护待抓取URL队列以及分发URL之外，还要负责调解各个Slave服务器的负载情况。以免某些Slave服务器过于清闲或者劳累。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 这种模式下，Master往往容易成为系统瓶颈。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 2.对等式（Peer to Peer）</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 对等式的基本结构如图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061822064864.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 在这种模式下，所有的抓取服务器在分工上没有不同。每一台抓取服务器都可以从待抓取在URL队列中获取URL，然后对该URL的主域名的hash值H，然后计算H mod m（其中m是服务器的数量，以上图为例，m为3），计算得到的数就是处理该URL的主机编号。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 举例：假设对于URL www.baidu.com，计算器hash值H=8，m=3，则H mod m=2，因此由编号为2的服务器进行该链接的抓取。假设这时候是0号服务器拿到这个URL，那么它将该URL转给服务器2，由服务器2进行抓取。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 这种模式有一个问题，当有一台服务器死机或者添加新的服务器，那么所有URL的哈希求余的结果就都要变化。也就是说，这种方式的扩展性不佳。针对这种情况，又有一种改进方案被提出来。这种改进的方案是一致性哈希法来确定服务器分工。其基本结构如图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"\" src=\"http://pic002.cnblogs.com/images/2012/51347/2012061822071171.png\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 一致性哈希将URL的主域名进行哈希运算，映射为一个范围在0-232之间的某个数。而将这个范围平均的分配给m台服务器，根据URL主域名哈希运算的值所处的范围判断是哪台服务器来进行抓取。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp; &nbsp; 如果某一台服务器出现问题，那么本该由该服务器负责的网页则按照顺时针顺延，由下一台服务器进行抓取。这样的话，及时某台服务器出现问题，也不会影响其他的工作。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">参考书目：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1.《这就是搜索引擎——核心技术详解》　　张俊林　　电子工业出版社</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">2.《搜索引擎技术基础》　　　　　　　　　刘奕群等　清华大学出版社</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">原文地址:<a href=\"http://www.cnblogs.com/wawlian/archive/2012/06/18/2553061.html\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">http://www.cnblogs.com/wawlian/archive/2012/06/18/2553061.html</a></p></ul><p><br/></p>', '2017-06-30 22:16:55', '/upload/image/20170914/1505396150002008886.jpg', '20', '好文推荐', '', '25', '技术博客', '网络爬虫基本原理');
INSERT INTO `blog_mgt` VALUES ('46', '不吃猫的鱼', 'admin', '5', '<ul class=\"infos list-paddingleft-2\" style=\"list-style-type: none;\"><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket用于在Web浏览器和服务器之间进行任意的双向数据传输的一种技术。WebSocket协议基于TCP协议实现，包含初始的握手过程，以及后续的多次数据帧双向传输过程。其目的是在WebSocket应用和WebSocket服务器进行频繁双向通信时，可以使服务器避免打开多个HTTP连接进行工作来节约资源，提高了工作效率和资源利用率。</p><h1 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>1. 引言</h1><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">互联网发展的早期，网站上只是一些静态展示页面。用户请求(Request)网站页面，网站回复(Response)页面内容给用户浏览器。因为需求简单，所以也没有很复杂的协议过程。这种形式的Request/Response交互流程如下图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">图&nbsp;11 Request/Response</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;随着互联网技术的发展，带宽逐步提高，用户数也越来越庞大。对互联网的呈现内容提出了要求，随之出现了动态页面技术，对同一个页面，页面的某些部分对不同的访问用户，呈现的内容不同。相关的实现技术有CGI、ASP、<a href=\"http://lib.csdn.net/base/php\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">PHP</a>、JSP等。由于访问量的增加，WEB服务器同时处理的用户数也达到了万(10K)以上级别，这就是C10K问题：&quot;<a href=\"http://www.kegel.com/c10k.html\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">The C10K problem</a>&quot;[1]。为了缓解服务器压力，每次Request/Response后连接(TCP连接)继续保持，以及对同一个TCP连接，多次复用Request/Response的方法(也称为Pipeline)也提了出来。这就是HTTP/1.1协议中长连接的主要内容。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;伴随移动互联网的发展，大量移动终端和其上的APP应用接入网络，<a href=\"http://lib.csdn.net/base/html5\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">HTML5</a>技术也提了出来，以便支持WEB上的音视频播放、实时游戏、实时聊天等。催生了这样一个<strong style=\"margin: 0px; padding: 0px;\">需求</strong>，当服务器有更新时，需要立即将数据发送给客户端，这就是基于服务器端的<strong style=\"margin: 0px; padding: 0px;\">推送</strong>技术。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;WEBSOCKET之前的解决方法大概这么几种： 1)轮询：客户端设置一个时间间隔，时间到以后，向服务器发送request询问有无新数据，服务器立即返回response，如果有更新则携带更新的数据。2)长连接(long poll): 和轮询相似，但是为阻塞模式的轮询，客户端请求新的数据request, 服务器会阻塞请求，直到有新数据后才返回response给客户端；然后客户端再重复此过程。这两种方式的特点，不断的建立HTTP连接，然后发送请求request，之后服务器等待处理。服务端体现的是一种<strong style=\"margin: 0px; padding: 0px;\">被动性</strong>，同时这种处理方式，非常耗费网络带宽和服务器资源。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;服务器向客户端<strong style=\"margin: 0px; padding: 0px;\">推送更新</strong>时，因为被动性，对低延迟的应用体验不好；因为request/response的交互方式，对网络带宽和服务器带来了额外的负担（例如多次请求的HTTP头部， TCP连接复用会导致的<a href=\"https://tools.ietf.org/id/draft-scharf-tcpm-reordering-00.html\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">Head-of-Line Blocking</a>线头阻塞[2]等）。如果在单一的TCP连接中，使用双向通信（全双工通信）就能很好的解决此问题。这就是WebSocket技术的缘由。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">&nbsp;</p><h1 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>2. WebSocket技术及协议</h1><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket技术的优点有：1）通过第一次HTTP Request建立了连接之后，后续的数据交换都不用再重新发送HTTP Request，节省了带宽资源； 2) WebSocket的连接是双向通信的连接，在同一个TCP连接上，既可以发送，也可以接收; 3)具有多路复用的功能(multiplexing)，也即几个不同的URI可以复用同一个WebSocket连接。这些特点非常类似TCP连接，但是因为它借用了HTTP协议的一些概念，所以被称为了WebSocket。</p><h2 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>2.1 WebSocket API</h2><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><a href=\"https://www.w3.org/TR/websockets/\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">WebSocket API</a>[3], 也称为WebSocket接口(Interface)，定义了Web应用和服务器进行双向通信的公共接口。 如下图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">图&nbsp;21 WebSocket API</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">接口的内容可以分为三类：<strong style=\"margin: 0px; padding: 0px;\">状态变量、网络功能和消息处理等</strong>。</p><ol style=\"padding: 0px;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">构造函数WebSocket(url, protocols)：构造WebSocket对象，以及建立和服务器连接; protocols可选字段，代表选择的子协议</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">状态变量readyState: 代表当前连接的状态，短整型数据，取值为CONNECTING(值为0)， OPEN(值为1), CLOSING(值为2), CLOSED(值为3)</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">方法变量close(code, reason)： 关闭此WebSocket连接。</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">状态变量bufferedAmount: send函数调用后，被缓存并且未发送到网络上的数据长度</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">方法变量send(data): 将数据data通过此WebSocket发送到对端</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">回调函数onopen/onmessage/onerror/onclose: 当相应的事件发生时会触发此回调函数</p></li></ol><h3 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>&nbsp;2.1.1&nbsp;示例</h3><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">客户端使用例子(<a href=\"http://lib.csdn.net/base/javascript\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">JavaScript</a>)：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">var&nbsp;websocket&nbsp;=&nbsp;new&nbsp;WebSocket(&quot;ws://www.host.com/path&quot;);&nbsp;&nbsp;&nbsp;\nwebsocket.onopen&nbsp;=&nbsp;function(evt)&nbsp;{&nbsp;onOpen(evt)&nbsp;};&nbsp;&nbsp;&nbsp;\nwebsocket.onclose&nbsp;=&nbsp;function(evt)&nbsp;{&nbsp;onClose(evt)&nbsp;};&nbsp;&nbsp;&nbsp;\nwebsocket.onmessage&nbsp;=&nbsp;function(evt)&nbsp;{&nbsp;onMessage(evt)&nbsp;};&nbsp;&nbsp;&nbsp;\nwebsocket.onerror&nbsp;=&nbsp;function(evt)&nbsp;{&nbsp;onError(evt)&nbsp;};&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;\nfunction&nbsp;onMessage(evt)&nbsp;{&nbsp;alert(&nbsp;evt.data);&nbsp;}&nbsp;&nbsp;\nfunction&nbsp;onError(evt)&nbsp;{&nbsp;alert(&nbsp;evt.data);&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;\nwebsocket.send(&quot;client&nbsp;to&nbsp;server&quot;);</pre><h2 style=\"margin: 0px; padding: 0px; font-weight: normal;\">2.2&nbsp;WebSocket协议</h2><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket看成是一种类似TCP/IP的socket技术；此socket在Web应用中实现，并获得了和TCP/IP通信一样灵活方便的全双向通信功能。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket协议由<a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">RFC 6455</a>定义。协议分为两个部分： 握手阶段和数据通信阶段。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket为应用层协议，其定义在TCP/IP协议栈之上。WebSocket连接服务器的URI以<strong style=\"margin: 0px; padding: 0px;\">&quot;ws&quot;</strong>或者<strong style=\"margin: 0px; padding: 0px;\">&quot;wss&quot;</strong>开头。ws开头的默认TCP端口为80，wss开头的默认端口为443。</p><h3 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>&nbsp;2.2.1&nbsp;握手阶段</h3><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">客户端和服务器建立TCP连接之后，客户端发送握手请求，随后服务器发送握手响应即完成握手阶段。如下图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"1505395792679094303.jpg\" src=\"/upload/image/20170914/1505395792679094303.jpg\" title=\"1505395792679094303.jpg\" width=\"361\" height=\"268\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">图&nbsp;22 Handshake</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">客户端握手请求类似如下：</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img alt=\"22-1F224113P0Y4.jpg\" src=\"/upload/image/20170914/1505395845832028407.jpg\" title=\"1505395845832028407.jpg\" width=\"1\" height=\"1\"/></p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">服务器的握手响应类似如下：</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">需要关闭连接时，任意一方直接发送类型为关闭帧(Close frame)的控制帧数据给对方即可。</p><h3 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>&nbsp;2.2.2&nbsp;数据通信</h3><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket的数据在发送时，被组织为依次序的一串<strong style=\"margin: 0px; padding: 0px;\">数据帧</strong>(data frame)，然后进行传送。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">传送的帧类型分为两类：数据帧(data frame)和控制帧(Control frame)。数据帧可以携带文本数据或者二进制数据；控制帧包含关闭帧(Close frame)和Ping/Pong帧。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">帧的格式如下所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img src=\"/upload/image/20170914/1505395900813046721.jpg\" title=\"1505395900813046721.jpg\" alt=\"1505395900813046721.jpg\" width=\"300\" height=\"200\"/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">其中最重要的字段为opcode(4bit)和MASK(1bit)：</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">MASK值，从客户端进行发送的帧必须置此位为1，从服务器发送的帧必须置为0。如果任何一方收到的帧不符合此要求，则发送关闭帧(Close frame)关闭连接。</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">opcode的值： 0x1代表此帧为文本数据帧, 0x2代表此帧为二进制数据帧, 0x8为控制帧中的连接关闭帧(close frame), 0x9为控制帧中的Ping帧, 0xA(十进制的10)为控制帧中的Pong帧。</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">Ping/Pong帧： Ping帧和Pong帧用于连接的保活(keepalive)或者诊断对端是否在线。这两种帧的发送和接收不对WEB应用公开接口，由实现WebSocket协议的底层应用(例如浏览器)来实现它。</p></li></ul><h3 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>&nbsp;2.2.3&nbsp;连接关闭</h3><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">任何一端发送关闭帧给对方，即可关闭连接。关闭连接时通常都带有关闭连接的状态码(status code)。常见<strong style=\"margin: 0px; padding: 0px;\">状态码</strong>的含义如下：</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1000 连接正常关闭</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1001 端点离线，例如服务器down，或者浏览器已经离开此页面</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1002 端点因为协议错误而中断连接</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1003 端点因为受到不能接受的数据类型而中断连接</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1004 保留</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1005 保留, 用于提示应用未收到连接关闭的状态码</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1006 端点异常关闭</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1007 端点收到的数据帧类型不一致而导致连接关闭</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1008 数据违例而关闭连接</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1009 收到的消息数据太大而关闭连接</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1010 客户端因为服务器未协商扩展而关闭</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1011 服务器因为遭遇异常而关闭连接</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">1015 TLS握手失败关闭连接</p></li></ul><h3 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>&nbsp;3.&nbsp;WebSocket示例</h3><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">这里以<a href=\"http://lib.csdn.net/base/java\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">Java</a>+Eclipse+TOMCAT+JDK8+浏览器，做为例子。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">具体代码</strong>见<a href=\"https://github.com/siwind/HelloWebJava\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">github链接</a><strong style=\"margin: 0px; padding: 0px;\">:</strong><a href=\"https://github.com/siwind/HelloWebJava\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\"><strong style=\"margin: 0px; padding: 0px;\">https://github.com/siwind/HelloWebJava</strong></a></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">以回声服务器为例，打开Eclipse，新建Web -- Dynamic Web Project项目，项目名称&quot;HelloWebJava&quot;</p><h2 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>&nbsp;3.1&nbsp;WebSocket服务端</h2><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">在项目中新建java类，采用注解的方式，实现OnOpen/OnClose/OnMessage回调方法即可。代码如下：</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">import&nbsp;java.io.IOException;&nbsp;&nbsp;\n&nbsp;&nbsp;\nimport&nbsp;javax.websocket.*;&nbsp;&nbsp;\nimport&nbsp;javax.websocket.server.ServerEndpoint;&nbsp;&nbsp;\n&nbsp;&nbsp;\n&nbsp;&nbsp;\n@ServerEndpoint(&quot;/WSHello&quot;)&nbsp;&nbsp;\npublic&nbsp;class&nbsp;HelloEndPoint&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;@OnOpen&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onOpen(Session&nbsp;session){&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Session&nbsp;&quot;&nbsp;+&nbsp;session.getId()&nbsp;+&nbsp;&quot;&nbsp;has&nbsp;opened&nbsp;a&nbsp;connection&quot;);&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getBasicRemote().sendText(&quot;Connection&nbsp;Established&quot;);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;ex)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex.printStackTrace();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;@OnMessage&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onMessage(String&nbsp;message,&nbsp;Session&nbsp;session){&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Message&nbsp;from&nbsp;&quot;&nbsp;+&nbsp;session.getId()&nbsp;+&nbsp;&quot;:&nbsp;&quot;&nbsp;+&nbsp;message);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getBasicRemote().sendText(message);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;ex)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex.printStackTrace();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;@OnClose&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onClose(Session&nbsp;session){&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Session&nbsp;&quot;&nbsp;+session.getId()+&quot;&nbsp;has&nbsp;closed!&quot;);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;注意:&nbsp;OnError()&nbsp;只能出现一次.&nbsp;&nbsp;&nbsp;其中的参数都是可选的。&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;session&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;t&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;@OnError&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onError(Session&nbsp;session,&nbsp;Throwable&nbsp;t)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.printStackTrace();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n}</pre><h2 style=\"margin: 0px; padding: 0px; font-weight: normal;\">3.2&nbsp;WebSocket浏览器客户端</h2><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">在项目的WebContent目录下面，新建名称为index.htm的文件，内容如下(部分):</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">webSocket&nbsp;=&nbsp;new&nbsp;WebSocket(wsUri);&nbsp;&nbsp;\nwebSocket.onopen&nbsp;=function(event){&nbsp;&nbsp;\nif(event.data&nbsp;===&nbsp;undefined)&nbsp;&nbsp;\nreturn;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;\nwriteResponse(event.data);&nbsp;&nbsp;\n};&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;\nwebSocket.onmessage&nbsp;=function(event){&nbsp;&nbsp;\nwriteResponse(event.data);&nbsp;&nbsp;\n};&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;\nwebSocket.onerror&nbsp;=function(event){&nbsp;&nbsp;\nwriteResponse(&quot;&lt;span&nbsp;style=&#39;color:&nbsp;red;&#39;&gt;ERROR:&nbsp;&lt;/span&gt;Connection&nbsp;error!&nbsp;&quot;&nbsp;+&nbsp;event.data);&nbsp;&nbsp;\n};&nbsp;&nbsp;\nwebSocket.onclose&nbsp;=function(event){&nbsp;&nbsp;\nwriteResponse(&quot;&lt;span&nbsp;style=&#39;color:&nbsp;blue;&#39;&gt;INFO:&nbsp;&lt;/span&gt;Connection&nbsp;closed.&nbsp;code=&quot;&nbsp;+&nbsp;event.code);&nbsp;&nbsp;\n};&nbsp;&nbsp;\n}</pre><h3 style=\"margin: 0px; padding: 0px; font-weight: normal;\">3.3&nbsp;部署及运行</h3><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">在JDK8环境下，部署到Tomcat8.0.x/Tomcat8.5.x/Wildfly10.x/Glassfish4.x，正常运行。如下图所示：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">图&nbsp;31 WebSocket Echo Example</p><h1 style=\"margin: 0px; padding: 0px; font-weight: normal;\"><a style=\"margin: 0px; padding: 0px; outline: none;\"></a>4. &nbsp;结论</h1><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket和传统的HTTP交互方式的区别如下图：</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">图&nbsp;41交互方式比较</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">WebSocket的<strong style=\"margin: 0px; padding: 0px;\">结论</strong>如下：</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">基于TCP/IP协议实现</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">是一种全双向的通信, 具有底层socket的特点</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">节约带宽，节省服务器资源</p></li><li><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">是HTML5的技术之一，具有巨大的应用前景</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">本文的完整示例代码：&nbsp;<a href=\"https://github.com/siwind/HelloWebJava\" target=\"_blank\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\"><strong style=\"margin: 0px; padding: 0px;\">https://github.com/siwind/HelloWebJava</strong></a></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">参考文献</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">[1] Dan Kegel. The C10K problem[EB/OL]. http://www.kegel.com/c10k.html.</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">[2] Head-of-line blocking[EB/OL]. https://en.wikipedia.org/wiki/Head-of-line_blocking.</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">[3] W3C Candidate Recommendation 20 September 2012. The WebSocket API[EB/OL]. https://www.w3.org/TR/websockets/.</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">原文地址:<a href=\"http://blog.csdn.net/yinqingwang/article/details/52565133\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">http://blog.csdn.net/yinqingwang/article/details/52565133</a></p></ul><p><br/></p>', '2017-06-30 22:18:13', '/upload/image/20170914/1505395792679094303.jpg', '20', '好文推荐', '', '25', '技术博客', 'WebSocket原理及技术简介');
INSERT INTO `blog_mgt` VALUES ('49', '烨', 'cyy123', '7', '<ul class=\"infos list-paddingleft-2\" style=\"list-style-type: none;\"><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\"><img src=\"/upload/image/20170703/1499068279242086893.jpg\" title=\"1499068279242086893.jpg\" alt=\"1499068279242086893.jpg\" width=\"300\" height=\"200\"/>在做混合应用时，H5与Native通信的重要性，我想每一个H5开发者都非常的清楚。通过它，我们可以很好的借用Native API的优势来实现自己想做的事情，业界有一个非常成熟的框架让大家选择，它就是PhoneGap。混合开发，并不是意味着什么App都可以做，它也有局限性。在写交互原理之前，我想先写写自己的体会。</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p>混合开发使用的语言是JavaScript由于系统分配的资源始终有限，在UIWebView这个容器中运行，效率跟原生的差距是非常明显的</p></li><li><p>应用需要解决首次加载白屏的问题，因为资源加载的速度始终有些慢</p></li><li><p>这玩意调试起来很痛苦，不像在web端有chrome的开发者工具，iOS有Xcode</p></li><li><p>iOS和android交互始终不一样，但是混合应用提供了一个统一的UI，目前不清楚用户是否能习惯交互</p></li><li><p>关于通信JavaScript到Native是一个异步的过程，而Native到JavaScript是一个同步的过程</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">那么使用混合应用在什么场景下比较有优势呢？</p><ul style=\"list-style-type: circle;\" class=\" list-paddingleft-2\"><li><p>内容驱动型的应用</p></li><li><p>经常需要调整UI的应用</p></li><li><p>经常需要调整业务的应用</p></li><li><p>交互不复杂并且不需要大量计算的应用</p></li></ul><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">总结起来，比如携程的App，因为都是内容驱动，比如购买门票，旅游之类的，又比如淘宝的App，大量商品类的展示，以及一些如图书，查询，工具类的应用，混合开发在这些场景下，有很明显的优势。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">言归正传，因为iOS并没有提供原生的调用API，所以当JavaScript跟Native进行通信时，就需要利用一些技巧了。UIWebView这个容器，除了可以加载请求之外，也可以加载本地资源，如果当一个页面发起请求时，是要经过UIWebView的，于是有人会想，我能知道这个URL么？不错，UIWebView可以拦截这个request，并且知道它的全部。那么UIWebView可以通知页面不，这个依然可以。利用这些原理技巧，于是两端通信的问题就解决了。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">在UIWebView中实现UIWebViewDelegate协议，就可以拦截到页面端发送的request。</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">(BOOL)webView:(UIWebView&nbsp;*)webView&nbsp;shouldStartLoadWithRequest:(NSURLRequest&nbsp;*)request&nbsp;navigationType:(UIWebViewNavigationType)navigationType\n{\n	NSURL&nbsp;*url&nbsp;=&nbsp;[request&nbsp;URL];	if&nbsp;([[url&nbsp;scheme]&nbsp;isEqualToString:@&quot;test&quot;])&nbsp;{\n		[_webView&nbsp;stringByEvaluatingJavaScriptFromString:@&quot;window.iOSPhoneName&nbsp;=&nbsp;&#39;iam&nbsp;lcepy&#39;&quot;];		return&nbsp;NO;\n	}	return&nbsp;YES;\n}</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">返回YES表示执行浏览器的默认执行，返回NO表示不执行浏览器的默认执行</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">而从Native到JavaScript可以利用上stringByEvaluatingJavaScriptFromString方法，执行Js字符串，它就能在UIWebView中执行这一段Js代码。在客户端，我们知道全局的对象是window，如果在客户端需要获取结果，可以把Native执行的结果放到window上。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">那么Js这一端如何实现呢？不错，利用的就是隐藏的iframe。</p><pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px;\">var&nbsp;requ&nbsp;=&nbsp;$(&#39;#requestToNative&#39;);\nrequ.bind(&#39;click&#39;,function(){	var&nbsp;iframe&nbsp;=&nbsp;document.createElement(&#39;iframe&#39;);\n	iframe.style.display&nbsp;=&nbsp;&#39;none&#39;;\n	iframe.src&nbsp;=&nbsp;&#39;test://iOS/userInfo&#39;;	var&nbsp;requs&nbsp;=&nbsp;requ[0];\n	requs.appendChild(iframe);\n	iframe&nbsp;=&nbsp;null;\n	alert(window.iOSPhoneName);\n});</pre><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">发送这个request让Native进行拦截，协议名可以随便取，当然这个名字要取的有意义。</p><p style=\"margin-top: 0px; margin-bottom: 20px; padding: 0px;\">原文地址:<a href=\"http://www.tuicool.com/articles/UruYv2A\" style=\"margin: 0px; padding: 0px; outline: none; text-decoration: none; color: rgb(102, 102, 102);\">http://www.tuicool.com/articles/UruYv2A</a></p></ul><p><br/></p>', '2017-07-03 15:52:07', '/upload/image/20170703/1499068279242086893.jpg', '47', '技术推荐', '', '48', '知乎推荐', 'Native与H5交互的原理');
INSERT INTO `blog_mgt` VALUES ('50', '不吃猫的鱼', 'admin', '3', '<p><img src=\"/upload/image/20170914/1505395184354083047.jpg\" title=\"1505395184354083047.jpg\" alt=\"1505395184354083047.jpg\" width=\"180\" height=\"160\"/></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 16px;\">前提：首先你必须知道，端口不是独立存在的，它是依附于进程的。某个进程开启，那么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再次开启，则相应的端口也再次开启。而不要纯粹的理解为关闭掉某个端口，不过可以禁用某个端口。<br/><br/>1. 可以通过&quot;netstat -anp&quot; 来查看哪些端口被打开。<br/>（注：加参数&#39;-n&#39;会将应用程序转为端口显示，即数字格式的地址，如：nfs-&gt;2049, ftp-&gt;21，因此可以开启两个终端，一一对应一下程序所对应的端口号）<br/>2. 然后可以通过&quot;lsof -i:$PORT&quot;查看应用该端口的程序（$PORT指对应的端口号）。或者你也可以查看文件/etc/services，从里面可以找出端口所对应的服务。<br/>（注：有些端口通过netstat查不出来，更可靠的方法是&quot;sudo nmap -sT -O localhost&quot;）<br/>3. 若要关闭某个端口，则可以：<img src=\"/upload/image/20170914/1505395286586014886.jpg\" title=\"1505395286586014886.jpg\" alt=\"1505395286586014886.jpg\" width=\"160\" height=\"120\"/>1)通过iptables工具将该端口禁掉，如：<br/>&quot;sudo iptables -A INPUT -p tcp --dport $PORT -j DROP&quot;<br/>&quot;sudo iptables -A OUTPUT -p tcp --dport $PORT -j DROP&quot;&nbsp;&nbsp;&nbsp;&nbsp;<br/>2)或者关掉对应的应用程序，则端口就自然关闭了，如：<br/>&quot;kill -9 PID&quot; (PID：进程号)<br/>如：&nbsp;&nbsp;&nbsp; 通过&quot;netstat -anp | grep ssh&quot;<br/>有显示：&nbsp;&nbsp;&nbsp; tcp 0 127.0.0.1:2121 0.0.0.0:* LISTEN 7546/ssh<br/>则：&nbsp;&nbsp;&nbsp; &quot;kill -9 7546&quot;<br/><br/>（可通过&quot;chkconfig&quot;查看系统服务的开启状态）</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">转自：<a href=\"http://apps.hi.baidu.com/share/detail/1192651\" target=\"_blank\" style=\"color: rgb(255, 153, 0); text-decoration: none;\">http://apps.hi.baidu.com/share/detail/1192651</a></p><p><br/></p>', '2017-09-14 21:22:41', '/upload/image/20170914/1505395184354083047.jpg', '20', '好文推荐', '', '25', '技术博客', 'Linux查看端口使用状态、关闭端口方法');
INSERT INTO `blog_mgt` VALUES ('53', '依然慢节奏', 'love1208tt', '1', '<p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\"><span style=\"margin: 0px; padding: 0px;\">linux系统下怎么关闭一个端口<img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/></span></p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">下面总结三种关闭linux系统端口的方法提供分享<img src=\"/upload/image/20170914/1505396759003035575.jpg\" title=\"1505396759003035575.jpg\" alt=\"banner_blog.jpg\"/></p><h2 style=\"margin: 0px; padding: 0px; font-size: 14px; line-height: 24px;\"><a target=\"_blank\" style=\"color: rgb(202, 0, 0);\"></a>1、通过杀掉进程的方法来关闭端口</h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">每个端口都有一个守护进程，kill掉这个守护进程就可以了</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">每个端口都是一个进程占用着，</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">第一步、用下面命令</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">netstat -anp |grep 端口</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">找出占用这个端口的进程，</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">第二步、用下面命令</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">kill -9 PID&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">杀掉就行了<br/></p><h2 style=\"margin: 0px; padding: 0px; font-size: 14px; line-height: 24px;\"><a target=\"_blank\" style=\"color: rgb(202, 0, 0);\"></a>2、通过开启关闭服务的方法来开启/关闭端口</h2><p>因为每个端口都有对应的服务，因此要关闭端口只要关闭相应的服务就可以了。<br/></p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">linux中开机自动启动的服务一般都存放在两个地方：</p><p><span style=\"margin: 0px; padding: 0px;\">/etc/init.d/文件夹下的服务：</span><br/>这个文件夹下的服务都可以通过运行相应的SCRIPT来启动或关闭。<br/>例如：启动sendmail服务： ./sendmail start (打开了TCP 25端口)<br/>关闭sendmail服务： ./sendmail stop （关闭TCP 25 端口）<br/></p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">查看sendmail服务当前状态： ./sendmail? status （查看服务是否运行）</p><p><span style=\"margin: 0px; padding: 0px;\">/etc/xinetd.d/文件夹下的服务：</span><br/>这个文件夹下的服务需要通过更改服务的配置文件，并重新启动xinetd才可以。<br/></p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">例如：要启动其中的auth服务，打开/etc/xinetd.d/auth配置文件，更改“disable=no”，保存退出。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">运行/etc/rc.d/init.d/xinetd restart&nbsp;</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">要停止其中的auth服务，打开/etc/xinetd.d/auth配置文件，更改“disable=yes”，保存退出。</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">运行/etc/rc.d/init.d/xinetd restart</p><h2 style=\"margin: 0px; padding: 0px; font-size: 14px; line-height: 24px;\"><a target=\"_blank\" style=\"color: rgb(202, 0, 0);\"></a>3、通过防火墙限制端口</h2><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">以下介绍的方法在<a target=\"_blank\" href=\"http://www.kubiji.cn/topic-id119.html\" style=\"color: rgb(100, 133, 76); text-decoration: none; margin: 0px; padding: 0px;\">Linux命令</a>下使用，很简便。<br/>开端口为：</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">iptables -A INPUT -p&nbsp;&nbsp; $port&nbsp;&nbsp; -j ACCEPT</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">关把ACCEPT改为DROP即可，即：</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">iptables -A INPUT -p $port&nbsp;&nbsp; -j DROP<br/>其中$port即为端口数字，iptables的具体用法可</p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\"><br/></p><p style=\"margin-top: 0px; margin-bottom: 15px; padding: 0px; color: rgb(37, 37, 37); line-height: 28px;\">原文链接:<a target=\"_blank\" href=\"http://www.kubiji.cn/topic-id320.html\" style=\"color: rgb(202, 0, 0); text-decoration: none;\">http://www.kubiji.cn/topic-id320.html</a></p><p><a href=\"http://blog.csdn.net/imatt/article/details/60469786#\" class=\"bds_more\" target=\"_blank\" style=\"color: rgb(51, 51, 51); text-decoration: none; float: left; font-size: 12px; padding-left: 17px; line-height: 16px; height: 16px; cursor: pointer; margin: 6px 6px 6px 0px; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png) !important; background-position: 0px 0px !important; background-repeat: no-repeat;\"></a><a href=\"http://blog.csdn.net/imatt/article/details/60469786#\" class=\"bds_qzone\" title=\"分享到QQ空间\" target=\"_blank\" style=\"color: rgb(202, 0, 0); text-decoration: none; float: left; font-size: 12px; padding-left: 17px; line-height: 16px; height: 16px; cursor: pointer; margin: 6px 6px 6px 0px; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=91362611.png); background-position: 0px -52px !important; background-repeat: no-repeat;\"></a><a href=\"http://blog.csdn.net/imatt/article/details/60469786#\" class=\"bds_tsina\" title=\"分享到新浪微博\" target=\"_blank\" style=\"color: rgb(202, 0, 0); text-decoration: none; float: left; font-size: 12px; padding-left: 17px; line-height: 16px; height: 16px; cursor: pointer; margin: 6px 6px 6px 0px; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=91362611.png); background-position: 0px -104px !important; background-repeat: no-repeat;\"></a><a href=\"http://blog.csdn.net/imatt/article/details/60469786#\" class=\"bds_tqq\" title=\"分享到腾讯微博\" target=\"_blank\" style=\"color: rgb(202, 0, 0); text-decoration: none; float: left; font-size: 12px; padding-left: 17px; line-height: 16px; height: 16px; cursor: pointer; margin: 6px 6px 6px 0px; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=91362611.png); background-position: 0px -260px !important; background-repeat: no-repeat;\"></a><a href=\"http://blog.csdn.net/imatt/article/details/60469786#\" class=\"bds_renren\" title=\"分享到人人网\" target=\"_blank\" style=\"color: rgb(202, 0, 0); text-decoration: none; float: left; font-size: 12px; padding-left: 17px; line-height: 16px; height: 16px; cursor: pointer; margin: 6px 6px 6px 0px; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=91362611.png); background-position: 0px -208px !important; background-repeat: no-repeat;\"></a><a href=\"http://blog.csdn.net/imatt/article/details/60469786#\" class=\"bds_weixin\" title=\"分享到微信\" target=\"_blank\" style=\"color: rgb(202, 0, 0); text-decoration: none; float: left; font-size: 12px; padding-left: 17px; line-height: 16px; height: 16px; cursor: pointer; margin: 6px 6px 6px 0px; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=91362611.png); background-position: 0px -1612px !important; background-repeat: no-repeat;\"></a></p><ul class=\"digg digg_disable list-paddingleft-2\" style=\"display: inline-block; float: left; width: 72px; height: 72px; overflow: hidden; margin: 0px 2px; color: rgb(255, 255, 255); cursor: pointer; background: rgb(153, 153, 153);\"></ul><p><br/></p>', '2017-09-14 21:46:01', 'http://img.baidu.com/hi/jx2/j_0003.gif', '51', '技术博客', '', '52', '常用技术', '3种关闭linux系统端口方法');

-- ----------------------------
-- Table structure for `comment_missbe`
-- ----------------------------
DROP TABLE IF EXISTS `comment_missbe`;
CREATE TABLE `comment_missbe` (
  `comment_id` int(11) NOT NULL AUTO_INCREMENT,
  `avator` varchar(255) DEFAULT NULL,
  `content` varchar(800) NOT NULL,
  `publisher` varchar(255) DEFAULT NULL,
  `status` bit(1) DEFAULT NULL,
  `time` varchar(255) DEFAULT NULL,
  `author` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`comment_id`),
  KEY `FKm87y8pbfi582jqu3o7trpf2qe` (`author`),
  CONSTRAINT `FKm87y8pbfi582jqu3o7trpf2qe` FOREIGN KEY (`author`) REFERENCES `user_mgt` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment_missbe
-- ----------------------------

-- ----------------------------
-- Table structure for `hibernate_sequence`
-- ----------------------------
DROP TABLE IF EXISTS `hibernate_sequence`;
CREATE TABLE `hibernate_sequence` (
  `next_val` bigint(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of hibernate_sequence
-- ----------------------------
INSERT INTO `hibernate_sequence` VALUES ('54');
INSERT INTO `hibernate_sequence` VALUES ('54');
INSERT INTO `hibernate_sequence` VALUES ('54');
INSERT INTO `hibernate_sequence` VALUES ('54');
INSERT INTO `hibernate_sequence` VALUES ('54');

-- ----------------------------
-- Table structure for `json_key_value_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `json_key_value_mgt`;
CREATE TABLE `json_key_value_mgt` (
  `key_` varchar(255) NOT NULL,
  `value` text NOT NULL,
  PRIMARY KEY (`key_`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of json_key_value_mgt
-- ----------------------------
INSERT INTO `json_key_value_mgt` VALUES ('about', '{}');
INSERT INTO `json_key_value_mgt` VALUES ('blog#admin', '{\"music\":\"晴天\",\"logo\":\"static/images/logo.jpg\",\"weixinQrcode\":\"/upload/image/20170702/1498972679754046071.png\",\"books\":\"程序员的自我修养\",\"timenow\":\"1498972681198\",\"bannerText\":\"\",\"job\":\"程序员\",\"photo\":\"static/images/photo.jpg\",\"nowAddress\":\"四川自贡\",\"englishName\":\"jay\",\"weixin\":\"依然慢节奏\",\"name\":\"不吃猫的鱼\",\"birthAddress\":\"四川巴中\",\"secondJob\":\"写代码\",\"birthDate\":\"1995.08\",\"realName\":\"依然慢节奏\",\"bannerImg\":\"static/images/banner_blog.jpg\",\"avator\":\"/upload/image/20170702/1498972667260088505.jpg\"}');
INSERT INTO `json_key_value_mgt` VALUES ('blog#cyy123', '{\"englishName\":\"cyy\",\"timenow\":\"1499068069208\",\"weixinQrcode\":\"static/images/weixin.jpg\",\"nowAddress\":\"四川自贡\",\"photo\":\"static/images/photo.jpg\",\"secondJob\":\"写代码\",\"birthDate\":\"1996.08\",\"realName\":\"依然范特西\",\"music\":\"\",\"books\":\"\",\"weixin\":\"Missbe\",\"bannerText\":\"带你装逼，带你飞....\",\"name\":\"烨\",\"logo\":\"static/images/logo.jpg\",\"avator\":\"/upload/image/20170914/1505396396378039423.jpg\",\"birthAddress\":\"四川自贡\",\"job\":\"程序员\",\"bannerImg\":\"static/images/banner_blog.jpg\"}');
INSERT INTO `json_key_value_mgt` VALUES ('blog#love1208tt', '{\"englishName\":\"love1208tt\",\"timenow\":\"1505396592737\",\"weixinQrcode\":\"static/images/weixin.jpg\",\"nowAddress\":\"四川\",\"photo\":\"static/images/photo.jpg\",\"secondJob\":\"代码\",\"birthDate\":\"1995.02.13\",\"realName\":\"慢节奏\",\"books\":\"程序员的自我修养\",\"music\":\"晴天\",\"weixin\":\"Missbe\",\"name\":\"依然慢节奏\",\"bannerText\":\"努力努力再努力.....\",\"avator\":\"/upload/image/20170914/1505396500172078362.jpg\",\"logo\":\"static/images/logo.jpg\",\"birthAddress\":\"四川\",\"job\":\"程序员\",\"bannerImg\":\"static/images/banner_blog.jpg\"}');
INSERT INTO `json_key_value_mgt` VALUES ('customs', '{}');
INSERT INTO `json_key_value_mgt` VALUES ('index', '{}');
INSERT INTO `json_key_value_mgt` VALUES ('services', '{}');

-- ----------------------------
-- Table structure for `menu_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `menu_mgt`;
CREATE TABLE `menu_mgt` (
  `id` bigint(20) NOT NULL,
  `authorAccount` varchar(255) DEFAULT NULL,
  `content` varchar(80) NOT NULL,
  `englishName` varchar(10) NOT NULL,
  `name` varchar(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of menu_mgt
-- ----------------------------
INSERT INTO `menu_mgt` VALUES ('20', 'admin', '有用喜欢的文章', 'Share', '好文推荐');
INSERT INTO `menu_mgt` VALUES ('21', 'admin', '生活纪念的事情', 'Life', '生活札记');
INSERT INTO `menu_mgt` VALUES ('47', 'cyy123', '技术推荐，实力学习新技术。', 'Share', '技术推荐');
INSERT INTO `menu_mgt` VALUES ('51', 'love1208tt', '技术博客', 'Blog', '技术博客');

-- ----------------------------
-- Table structure for `message_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `message_mgt`;
CREATE TABLE `message_mgt` (
  `id` bigint(20) NOT NULL,
  `contact` varchar(30) NOT NULL,
  `date` varchar(255) DEFAULT NULL,
  `handle` bit(1) NOT NULL,
  `ip` varchar(255) DEFAULT NULL,
  `message` text NOT NULL,
  `name` varchar(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of message_mgt
-- ----------------------------

-- ----------------------------
-- Table structure for `news_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `news_mgt`;
CREATE TABLE `news_mgt` (
  `id` bigint(20) NOT NULL,
  `author` varchar(255) NOT NULL,
  `click` bigint(20) NOT NULL,
  `content` text NOT NULL,
  `createDate` datetime DEFAULT NULL,
  `title` varchar(48) NOT NULL,
  `top` bit(1) NOT NULL,
  `type` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of news_mgt
-- ----------------------------

-- ----------------------------
-- Table structure for `permission_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `permission_mgt`;
CREATE TABLE `permission_mgt` (
  `pms_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `permission` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`pms_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of permission_mgt
-- ----------------------------
INSERT INTO `permission_mgt` VALUES ('1', '联系我们', '/admin/contact');
INSERT INTO `permission_mgt` VALUES ('2', '合作客户', '/admin/customs');
INSERT INTO `permission_mgt` VALUES ('3', '首页', '/admin/index');
INSERT INTO `permission_mgt` VALUES ('4', '新闻添加修改', '/admin/news/add');
INSERT INTO `permission_mgt` VALUES ('5', '产品服务', '/admin/services');
INSERT INTO `permission_mgt` VALUES ('6', '关于我们', '/admin/about');
INSERT INTO `permission_mgt` VALUES ('10', '权限管理', '/admin/permission');

-- ----------------------------
-- Table structure for `role_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `role_mgt`;
CREATE TABLE `role_mgt` (
  `role_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `description` varchar(50) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of role_mgt
-- ----------------------------
INSERT INTO `role_mgt` VALUES ('12', 'admin', 'admin');
INSERT INTO `role_mgt` VALUES ('14', '首页内容管理角色，管理首页内容', '首页内容管理角色');

-- ----------------------------
-- Table structure for `role_permission_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `role_permission_mgt`;
CREATE TABLE `role_permission_mgt` (
  `role_id` bigint(20) NOT NULL,
  `pms_id` bigint(20) NOT NULL,
  KEY `FKbhniraml98bs4jtufol595el4` (`pms_id`),
  KEY `FKacdq6mmwyc08dv7w5wv00n9x3` (`role_id`),
  CONSTRAINT `FKacdq6mmwyc08dv7w5wv00n9x3` FOREIGN KEY (`role_id`) REFERENCES `role_mgt` (`role_id`),
  CONSTRAINT `FKbhniraml98bs4jtufol595el4` FOREIGN KEY (`pms_id`) REFERENCES `permission_mgt` (`pms_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of role_permission_mgt
-- ----------------------------
INSERT INTO `role_permission_mgt` VALUES ('12', '1');
INSERT INTO `role_permission_mgt` VALUES ('12', '2');
INSERT INTO `role_permission_mgt` VALUES ('12', '3');
INSERT INTO `role_permission_mgt` VALUES ('12', '4');
INSERT INTO `role_permission_mgt` VALUES ('12', '5');
INSERT INTO `role_permission_mgt` VALUES ('12', '6');
INSERT INTO `role_permission_mgt` VALUES ('12', '10');
INSERT INTO `role_permission_mgt` VALUES ('14', '1');
INSERT INTO `role_permission_mgt` VALUES ('14', '2');
INSERT INTO `role_permission_mgt` VALUES ('14', '5');
INSERT INTO `role_permission_mgt` VALUES ('14', '6');

-- ----------------------------
-- Table structure for `section_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `section_mgt`;
CREATE TABLE `section_mgt` (
  `id` bigint(20) NOT NULL,
  `authorAccount` varchar(255) DEFAULT NULL,
  `content` varchar(80) NOT NULL,
  `description` varchar(255) NOT NULL,
  `indexShow` bit(1) NOT NULL,
  `menu` varchar(255) NOT NULL,
  `menuName` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of section_mgt
-- ----------------------------
INSERT INTO `section_mgt` VALUES ('22', 'admin', '生活中有趣的事情', '趣事', '', '21', '生活札记');
INSERT INTO `section_mgt` VALUES ('23', 'admin', '生活中值得纪念的事情', '纪念', '', '21', '生活札记');
INSERT INTO `section_mgt` VALUES ('24', 'admin', '图文生活，我的生活', '图文记忆', '', '21', '生活札记');
INSERT INTO `section_mgt` VALUES ('25', 'admin', '学习新技术，技术交流', '技术博客', '', '20', '好文推荐');
INSERT INTO `section_mgt` VALUES ('26', 'admin', '鸡汤，你懂得', '知乎鸡汤', '', '20', '好文推荐');
INSERT INTO `section_mgt` VALUES ('27', 'admin', '开源的相关技术介绍', '开源技术', '', '20', '好文推荐');
INSERT INTO `section_mgt` VALUES ('28', 'admin', '经典文章，经久不衰', '经典文章', '', '20', '好文推荐');
INSERT INTO `section_mgt` VALUES ('48', 'cyy123', '知乎上推荐的文章，前沿新技术', '知乎推荐', '', '47', '技术推荐');
INSERT INTO `section_mgt` VALUES ('52', 'love1208tt', '常用技术', '常用技术', '', '51', '技术博客');

-- ----------------------------
-- Table structure for `system_config_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `system_config_mgt`;
CREATE TABLE `system_config_mgt` (
  `id` varchar(255) NOT NULL,
  `important` bit(1) NOT NULL,
  `text` varchar(255) DEFAULT NULL,
  `value` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of system_config_mgt
-- ----------------------------
INSERT INTO `system_config_mgt` VALUES ('system.log.printLevel', '', '系统打印日志等级', 'DEBUG');
INSERT INTO `system_config_mgt` VALUES ('system.log.saveDBLevel', '', '系统日志数据库存储等级', 'WARNING');
INSERT INTO `system_config_mgt` VALUES ('system.mode.online', '', '是否是线上模式', 'true');
INSERT INTO `system_config_mgt` VALUES ('system.user.initPassword', '', '用户初始密码', 'admin');

-- ----------------------------
-- Table structure for `system_log_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `system_log_mgt`;
CREATE TABLE `system_log_mgt` (
  `id` bigint(20) NOT NULL,
  `ip` varchar(255) DEFAULT NULL,
  `level` varchar(255) DEFAULT NULL,
  `msg` text,
  `params` text,
  `time` datetime DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of system_log_mgt
-- ----------------------------

-- ----------------------------
-- Table structure for `themes_comments_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `themes_comments_mgt`;
CREATE TABLE `themes_comments_mgt` (
  `themes_comments_id` int(11) NOT NULL,
  `comments_themes_id` int(11) NOT NULL,
  KEY `FKc4rsefa0r01jfmc021avx325l` (`comments_themes_id`),
  KEY `FKhpakylf4l0i3r5l2afda2r54u` (`themes_comments_id`),
  CONSTRAINT `FKc4rsefa0r01jfmc021avx325l` FOREIGN KEY (`comments_themes_id`) REFERENCES `comment_missbe` (`comment_id`),
  CONSTRAINT `FKhpakylf4l0i3r5l2afda2r54u` FOREIGN KEY (`themes_comments_id`) REFERENCES `themes_missbe` (`theme_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of themes_comments_mgt
-- ----------------------------

-- ----------------------------
-- Table structure for `themes_missbe`
-- ----------------------------
DROP TABLE IF EXISTS `themes_missbe`;
CREATE TABLE `themes_missbe` (
  `theme_id` int(11) NOT NULL AUTO_INCREMENT,
  `avator` varchar(255) DEFAULT NULL,
  `content` text NOT NULL,
  `publisher` varchar(255) DEFAULT NULL,
  `status` bit(1) DEFAULT NULL,
  `time` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `author` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`theme_id`),
  KEY `FK3t995naeux7upx73f6ma2u55u` (`blog_id`),
  KEY `FK8h1jrxkc8i0lnwcn7esbds7jw` (`author`),
  CONSTRAINT `FK3t995naeux7upx73f6ma2u55u` FOREIGN KEY (`blog_id`) REFERENCES `blog_mgt` (`id`),
  CONSTRAINT `FK8h1jrxkc8i0lnwcn7esbds7jw` FOREIGN KEY (`author`) REFERENCES `user_mgt` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of themes_missbe
-- ----------------------------

-- ----------------------------
-- Table structure for `user_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `user_mgt`;
CREATE TABLE `user_mgt` (
  `user_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account` varchar(50) NOT NULL,
  `avator` varchar(255) NOT NULL,
  `lastLoginTime` datetime DEFAULT NULL,
  `nickname` varchar(16) NOT NULL,
  `password` varchar(50) DEFAULT NULL,
  `status` int(11) NOT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user_mgt
-- ----------------------------
INSERT INTO `user_mgt` VALUES ('1', 'admin', '/upload/image/20170702/1498972667260088505.jpg', '2017-09-14 21:40:18', 'admin', '21232f297a57a5a743894a0e4a801fc3', '0');
INSERT INTO `user_mgt` VALUES ('3', 'cyy123', '/upload/image/20170914/1505396396378039423.jpg', '2017-09-14 21:38:59', 'cyy123', '519f419ad5bd26568482dc755fe26280', '0');
INSERT INTO `user_mgt` VALUES ('4', 'love1208tt', '/upload/image/20170914/1505396500172078362.jpg', '2017-09-14 21:41:26', 'love1208tt', '5cf82f427b8aaf19b4fc5414ebaf4152', '0');

-- ----------------------------
-- Table structure for `user_role_mgt`
-- ----------------------------
DROP TABLE IF EXISTS `user_role_mgt`;
CREATE TABLE `user_role_mgt` (
  `user_id` bigint(20) NOT NULL,
  `role_id` bigint(20) NOT NULL,
  KEY `FK5hqixsqepxljate1cxl4fic6k` (`role_id`),
  KEY `FK4q8cexbv02fng8rps8i5yaqpx` (`user_id`),
  CONSTRAINT `FK4q8cexbv02fng8rps8i5yaqpx` FOREIGN KEY (`user_id`) REFERENCES `user_mgt` (`user_id`),
  CONSTRAINT `FK5hqixsqepxljate1cxl4fic6k` FOREIGN KEY (`role_id`) REFERENCES `role_mgt` (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user_role_mgt
-- ----------------------------
INSERT INTO `user_role_mgt` VALUES ('1', '12');
INSERT INTO `user_role_mgt` VALUES ('4', '14');
INSERT INTO `user_role_mgt` VALUES ('3', '14');
